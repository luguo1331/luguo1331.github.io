<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junyi&#39;s Blog</title>
  
  <subtitle>求个offer回家过年</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-27T14:40:52.819Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.junyi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Zookeeper安装</title>
    <link href="http://yoursite.com/2018/08/27/Zookeeper%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/08/27/Zookeeper安装/</id>
    <published>2018-08-27T14:35:26.000Z</published>
    <updated>2018-08-27T14:40:52.819Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文将简单介绍一下 Zookeeper 的安装</p></blockquote><a id="more"></a><h5 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h5><ul><li>CentOS    7.3</li><li>Zookeeper 3.4.12</li></ul><h3 id="Zookeeper-简介"><a href="#Zookeeper-简介" class="headerlink" title="Zookeeper 简介"></a>Zookeeper 简介</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文将简单介绍一下 Zookeeper 的安装&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Zookeeper" scheme="http://yoursite.com/categories/Zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>设计RandomPool结构</title>
    <link href="http://yoursite.com/2018/08/20/%E8%AE%BE%E8%AE%A1RandomPool%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/08/20/设计RandomPool结构/</id>
    <published>2018-08-20T15:18:52.000Z</published>
    <updated>2018-08-20T15:45:04.543Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p>设计一种结构，在该结构中有如下三个功能：<br>insert(key)：将某个key加入到该结构，做到不重复加入。<br>delete(key)：将原本在结构中的某个key移除。<br>getRandom()：等概率随机返回结构中的任何一个key。<br><a id="more"></a><br>【要求】 Insert、delete和getRandom方法的时间复杂度都O(1)</p><h3 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现思路很简单，就是用两个 hashmap 来构成这个结构， keyIndexMap 、 indexKeyMap ,看到两个名字就懂了，没什么好说的。但是在实现 delete() 方法的时候要注意一下，如果直接将 map 中的元素删除掉，就会在 map 中留下一个空，当 getRandom() 的时候 时间复杂度就会不达标了，所以我们在删除的时候，用最后一个元素替换掉要删除的元素，同时把 size 减一，删掉最后一个，稳了。</p><h3 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pool&lt;K&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Integer&gt; keyIndexMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, K&gt; indexKeyMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keyIndexMap = <span class="keyword">new</span> HashMap&lt;K, Integer&gt;();</span><br><span class="line"><span class="keyword">this</span>.indexKeyMap = <span class="keyword">new</span> HashMap&lt;Integer, K&gt;();</span><br><span class="line"><span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.keyIndexMap.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">this</span>.keyIndexMap.put(key, <span class="keyword">this</span>.size);</span><br><span class="line">            <span class="keyword">this</span>.IndexKeyMap.put(<span class="keyword">this</span>.size++, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K Key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.keyIndexMap.containsKey(Key))&#123;</span><br><span class="line">            <span class="keyword">int</span> deleteIndex = <span class="keyword">this</span>.keyIndexMap.get(key);</span><br><span class="line">            <span class="keyword">int</span> lastIndex = --<span class="keyword">this</span>.size;</span><br><span class="line">            K lastKey = <span class="keyword">this</span>.indexMap.get(lastIndex);</span><br><span class="line">            <span class="keyword">this</span>.keyIndexMap.put(lastKey, deleteIndex);</span><br><span class="line">            <span class="keyword">this</span>.indexKeyMap.put(deleteIndex, lastKey);</span><br><span class="line">            <span class="keyword">this</span>.keyIndexMap.remove(key);</span><br><span class="line">            <span class="keyword">this</span>.indexKeyMap.remove(lastIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getRandom</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> randomIndex = (<span class="keyword">int</span>)(Math.random() * <span class="keyword">this</span>.size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.indexKeyMap.get(randomIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目】&quot;&gt;&lt;a href=&quot;#【题目】&quot; class=&quot;headerlink&quot; title=&quot;【题目】&quot;&gt;&lt;/a&gt;【题目】&lt;/h3&gt;&lt;p&gt;设计一种结构，在该结构中有如下三个功能：&lt;br&gt;insert(key)：将某个key加入到该结构，做到不重复加入。&lt;br&gt;delete(key)：将原本在结构中的某个key移除。&lt;br&gt;getRandom()：等概率随机返回结构中的任何一个key。&lt;br&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>已知一棵完全二叉树，求其节点的个数</title>
    <link href="http://yoursite.com/2018/08/20/%E5%B7%B2%E7%9F%A5%E4%B8%80%E6%A3%B5%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E6%B1%82%E5%85%B6%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2018/08/20/已知一棵完全二叉树，求其节点的个数/</id>
    <published>2018-08-20T14:31:34.000Z</published>
    <updated>2018-08-20T14:50:57.178Z</updated>
    
    <content type="html"><![CDATA[<p>已知一棵完全二叉树，求其节点的个数<br>要求：时间复杂度低于O(N)，N为这棵树的节点个数<br><a id="more"></a></p><h3 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题做得比较巧妙，首先我们算出左子树的高度，再计算出右子树的高度，再一比较，如果相等则证明左子树是满的，我们可以依据公式 2^h -1 算出左子树的节点数，如果右子树的高度比左子树小，则证明右子树的慢的，于是按照公式计算右子树的节点数，再递归计算左子树。依次类推，稳了。</p><h3 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nodeNum</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        retrun <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bs(head, <span class="number">1</span>, mostLeftLevel(head, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs</span><span class="params">(Node head, <span class="keyword">int</span> level, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level == h)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mostLeftLevel(node.right, level + <span class="number">1</span>) == h)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - level))  + bs(node.right, level + <span class="number">1</span>, h);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - level - <span class="number">1</span>)) + bs(node.left, level + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mostLeftLevel</span><span class="params">(Node node, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        level++;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已知一棵完全二叉树，求其节点的个数&lt;br&gt;要求：时间复杂度低于O(N)，N为这棵树的节点个数&lt;br&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>判断一棵二叉树是否是平衡二叉树、搜索二叉树、完全二叉树</title>
    <link href="http://yoursite.com/2018/08/20/%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2018/08/20/判断一棵二叉树是否是平衡二叉树/</id>
    <published>2018-08-20T12:33:17.000Z</published>
    <updated>2018-08-20T14:19:34.419Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>判断一棵二叉树是否是平衡二叉树、搜索二叉树、完全二叉树</p></blockquote><a id="more"></a><h3 id="【平衡二叉树】"><a href="#【平衡二叉树】" class="headerlink" title="【平衡二叉树】"></a>【平衡二叉树】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平衡二叉树就是其中每个结点的左子树和右子树的高度差至多等于1，实现思路很简单，在之前我们后序遍历二叉树的时候，会按照左右根的顺序，三次经过根节点，我们可以由此得到启发，同样按照左右根的顺序递归遍历二叉树，递归到空节点返回该节点的层次数到该节点的父节点，同理递归算出该父节点的右字数的层次，两个数一减看高度差是否超过一，超过一就把 res[0] 设置为 false ,以此让父节点判断是否平衡。以此类推，就能判断一个树是否为平衡二叉树了。</p><h4 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalance</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] res = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span>];</span><br><span class="line">    res[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    getHeight(head,<span class="number">1</span>,res);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node head, <span class="keyword">int</span> level, <span class="keyword">boolean</span>[] res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftHight = getHeight(head, level + <span class="number">1</span>, res);</span><br><span class="line">    <span class="keyword">if</span>(!res[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rightHeight = getHeight(head, level + <span class="number">1</span>, res);</span><br><span class="line">    <span class="keyword">if</span>(!res[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight,rightHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【搜索二叉树】"><a href="#【搜索二叉树】" class="headerlink" title="【搜索二叉树】"></a>【搜索二叉树】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;搜索二叉树的定义是若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树，简单来讲就是在一棵树内，任意节点的左节点都比节点小，右节点都比父节点大。定义清楚了，其实答案就差不多出来了，按照搜索树的性质如果我们按左根右的顺序中序遍历二叉树，那么它的前面的节点必定小于后面的节点，因此我们把中序遍历二叉树的函数改改不就稳了。</p><h4 id="【代码实现】-1"><a href="#【代码实现】-1" class="headerlink" title="【代码实现】"></a>【代码实现】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBST1</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head);</span><br><span class="line">                head = head.left</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(pre &gt; head.value)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBST2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">Node pre = <span class="keyword">null</span>;</span><br><span class="line">Node cur1 = head;</span><br><span class="line">Node cur2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (cur1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">cur2 = cur1.left;</span><br><span class="line"><span class="keyword">if</span> (cur2 != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (cur2.right != <span class="keyword">null</span> &amp;&amp; cur2.right != cur1) &#123;</span><br><span class="line">cur2 = cur2.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur2.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">cur2.right = cur1;</span><br><span class="line">cur1 = cur1.left;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur2.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.value &gt; cur1.value) &#123;</span><br><span class="line">res = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre = cur1;</span><br><span class="line">cur1 = cur1.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="【完全二叉树】"><a href="#【完全二叉树】" class="headerlink" title="【完全二叉树】"></a>【完全二叉树】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全二叉树，就是对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。看起来很复杂，想想其实要判断是否为完全二叉树，总共有四种情况，有左有右（是），有右没左（不是），有左没右、没左没右要判断后面遇到的节点是否全部为叶子节点。所以我们可以按层遍历数组，如果遇到有右没左或者有左没右、没左没右后面不是叶子节点的直接返回 false ， 否则将左右节点放入队列中，如果左右节点有一方为空则 leaf 设置为 true ，让下一轮判断是否为叶子节点。</p><h4 id="【代码实现】-2"><a href="#【代码实现】-2" class="headerlink" title="【代码实现】"></a>【代码实现】</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">isCBT</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">    Node left = <span class="keyword">null</span>;</span><br><span class="line">    Node right = <span class="keyword">null</span>;</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        head = queue.pop();</span><br><span class="line">        left = head.left;</span><br><span class="line">        right = head.right;</span><br><span class="line">        <span class="keyword">if</span>(leaf &amp;&amp; (left != <span class="keyword">null</span> || right != <span class="keyword">null</span>) || (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            leaf = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;判断一棵二叉树是否是平衡二叉树、搜索二叉树、完全二叉树&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树的序列化和反序列化</title>
    <link href="http://yoursite.com/2018/08/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2018/08/18/二叉树的序列化和反序列化/</id>
    <published>2018-08-18T08:13:39.000Z</published>
    <updated>2018-08-18T08:52:17.575Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍二叉树的序列化和反序列化</p></blockquote><a id="more"></a><h3 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;序列化没什么好讲的，其实跟遍历差不多。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反序列化,就是将序列化反过来。。。。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面的实现都比较简单，那如果要按层序列化呢？</p><h3 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByPre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String res = head.value + <span class="string">"!"</span>;</span><br><span class="line">    res += seralByPre(head.left);</span><br><span class="line">    res += seralByPre(head.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByPreString</span><span class="params">(String preStr)</span></span>&#123;</span><br><span class="line">    String[] values = preStr.split(<span class="string">"!"</span>);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != values.length; i++)&#123;</span><br><span class="line">        queue.offer(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reconPreOder(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconPreOder</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">    String value = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(value.equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">    head.left = reconPreOder(queue);</span><br><span class="line">    head.right = reconPreQder(queue);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByLevel</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">&#125;</span><br><span class="line">String res = head.value + <span class="string">"!"</span>;</span><br><span class="line">Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">queue.offer(head);</span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">head = queue.poll();</span><br><span class="line"><span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">res += head.left.value + <span class="string">"!"</span>;</span><br><span class="line">queue.offer(head.left);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res += <span class="string">"#!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">res += head.right.value + <span class="string">"!"</span>;</span><br><span class="line">queue.offer(head.right);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res += <span class="string">"#!"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByLevelString</span><span class="params">(String levelStr)</span> </span>&#123;</span><br><span class="line">String[] values = levelStr.split(<span class="string">"!"</span>);</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">Node head = generateNodeByString(values[index++]);</span><br><span class="line">Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line"><span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.offer(head);</span><br><span class="line">&#125;</span><br><span class="line">Node node = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">node = queue.poll();</span><br><span class="line">node.left = generateNodeByString(values[index++]);</span><br><span class="line">node.right = generateNodeByString(values[index++]);</span><br><span class="line"><span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.offer(node.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">queue.offer(node.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generateNodeByString</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (val.equals(<span class="string">"#"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Node(Integer.valueOf(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test -- print tree</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Binary Tree:"</span>);</span><br><span class="line">printInOrder(head, <span class="number">0</span>, <span class="string">"H"</span>, <span class="number">17</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInOrder</span><span class="params">(Node head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">printInOrder(head.right, height + <span class="number">1</span>, <span class="string">"v"</span>, len);</span><br><span class="line">String val = to + head.value + to;</span><br><span class="line"><span class="keyword">int</span> lenM = val.length();</span><br><span class="line"><span class="keyword">int</span> lenL = (len - lenM) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> lenR = len - lenM - lenL;</span><br><span class="line">val = getSpace(lenL) + val + getSpace(lenR);</span><br><span class="line">System.out.println(getSpace(height * len) + val);</span><br><span class="line">printInOrder(head.left, height + <span class="number">1</span>, <span class="string">"^"</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">String space = <span class="string">" "</span>;</span><br><span class="line">StringBuffer buf = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">buf.append(space);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍二叉树的序列化和反序列化&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>在二叉树中找到一个节点的后继节点</title>
    <link href="http://yoursite.com/2018/08/18/%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2018/08/18/在二叉树中找到一个节点的后继节点/</id>
    <published>2018-08-18T07:15:17.000Z</published>
    <updated>2018-08-18T08:11:40.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p>现在有一种新的二叉树节点类型如下：<br>public class Node { public int value; public Node left;<br>public Node right; public Node parent;<br>public Node(int data) { this.value = data; }<br>}<br><a id="more"></a><br>该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设有一 棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向 自己的父节点，头节点的parent指向null。只给一个在二叉树中的某个节点 node，请实现返回node的后继节点的函数。在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点。</p><h3 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题实现思路很简单，中序遍历就是左根右，遍历当中每一个节点都是“根”，它的后继节点必定出现在“右”当中，所以如果一个节点有右孩子，在遍历右孩子的过程中必定是从右孩子的最左边的节点开始遍历，那么后继节点就是这个<strong>右孩子的最左节点</strong>。如果一个节点没有右孩子，那么就去找它的父节点，如果它的父节点的左孩子等于 node 的话，后继就是它父亲。拓展一下的话，如果面试中有人问你前驱节点怎么找，反过来就是了，<strong>左孩子的最右节点</strong>，没有右孩子就去找他父亲的右孩子是不是和 node 相等。</p><h3 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getNextNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node parent = node.parent;</span><br><span class="line">        <span class="keyword">while</span>(parent != <span class="keyword">null</span> &amp;&amp; parent.left != node)&#123;</span><br><span class="line">            node = parent;</span><br><span class="line">            parent = node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目】&quot;&gt;&lt;a href=&quot;#【题目】&quot; class=&quot;headerlink&quot; title=&quot;【题目】&quot;&gt;&lt;/a&gt;【题目】&lt;/h3&gt;&lt;p&gt;现在有一种新的二叉树节点类型如下：&lt;br&gt;public class Node { public int value; public Node left;&lt;br&gt;public Node right; public Node parent;&lt;br&gt;public Node(int data) { this.value = data; }&lt;br&gt;}&lt;br&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树的先序、中序、后序遍历</title>
    <link href="http://yoursite.com/2018/08/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2018/08/18/二叉树的先序、中序、后序遍历/</id>
    <published>2018-08-18T03:57:00.000Z</published>
    <updated>2018-08-18T06:58:53.980Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文将简单介绍一下二叉树的先序、中序、后序遍历的递归实现和非递归实现。</p></blockquote><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历前先明确一下先序、中序、后序的意思，简单来讲就是，先序(根左右)、中序(左根右)、后序(左右根)。</p><h3 id="【递归方法】"><a href="#【递归方法】" class="headerlink" title="【递归方法】"></a>【递归方法】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先来讲一下递归实现，没有别的原因，因为它比较简单。</p><h4 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h4><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="递归先序遍历"><a href="#递归先序遍历" class="headerlink" title="递归先序遍历"></a>递归先序遍历</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(head.value + <span class="string">"  "</span>);</span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="递归中序遍历"><a href="#递归中序遍历" class="headerlink" title="递归中序遍历"></a>递归中序遍历</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderRecur(head.left);</span><br><span class="line">    System.out.print(head.value + <span class="string">"  "</span>);</span><br><span class="line">    inOrderRecur(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="递归后序遍历"><a href="#递归后序遍历" class="headerlink" title="递归后序遍历"></a>递归后序遍历</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderRecur(head.left);</span><br><span class="line">    inOrderRecur(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">"  "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【非递归方法】"><a href="#【非递归方法】" class="headerlink" title="【非递归方法】"></a>【非递归方法】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非递归方式实现起来会复杂一点，其实就是自己手动去压栈而已。</p><h4 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先序遍历，先生成一个栈 stack ，因为先序遍历是根左右，而栈的特点又是先进后出，所以除了根节点其它节点都是先进右孩子再进左孩子，这样出来的时候就是左孩子先出来，左孩子出来后，再被压栈的就是左孩子的孩子节点，如此类推根节点的左孩子被全部遍历，然后再到根节点的右孩子出栈，直到栈为空，稳了。</p><h5 id="【代码实现】-1"><a href="#【代码实现】-1" class="headerlink" title="【代码实现】"></a>【代码实现】</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pre-order:"</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        stack.add(head);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span>(head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printIn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中序遍历也是大同小异，要想达到左根右的效果，就必须先吧所以左孩子放入栈中，因此 head 不断向左，直到为空的时候就证明最后一个左节点已经放入栈中了，这时候就可以出栈了，因为最后一个左节点的没有左孩子，所以这时候相当于“根右”，所以指针指向右。如此类推，直到栈空、树空，稳了。</p><h5 id="【代码实现】-2"><a href="#【代码实现】-2" class="headerlink" title="【代码实现】"></a>【代码实现】</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"in-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head);</span><br><span class="line">                head = head.left</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head = stack.pop();</span><br><span class="line">                System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后序遍历会比较绕，如果仔细研究一下会发现，递归实现遍历二叉树时，每个节点过经过三次，而前面非递归实现的先序、中序遍历只经过了两次，但是问题是现在要实现左右根，那么根节点必定是第三次经过的时候才被打印，这就麻烦了。不过，其实先序是根左右，后序是左右根，那么我先实现一个根右左放到栈里面再出栈不就稳了吗。</p><h5 id="【代码实现】-3"><a href="#【代码实现】-3" class="headerlink" title="【代码实现】"></a>【代码实现】</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur1</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        s1.push(head);</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">            head = s1.pop();</span><br><span class="line">            s2.push(head);</span><br><span class="line">            <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                s1.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                s1.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">            Sysem.out.print(s2.pop().value + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">System.out.println();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归后序遍历-一个栈"><a href="#非递归后序遍历-一个栈" class="headerlink" title="非递归后序遍历(一个栈)"></a>非递归后序遍历(一个栈)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后序遍历的实现用多了一个栈，那么不用加多一个栈行不行，答案是可以的，用指针 h 指向最近出栈的节点， 指针 c 代表栈顶的节点，如果当栈顶节点的左孩子、右孩子都不是最近出栈的节点，且左孩子存在那么证明栈顶节点的左孩子还没有打印，所以栈顶节点的左孩子入栈，否则就可能是右孩子没有打印，所以右孩子入栈，如果上面的情况都不存在，就证明栈顶节点的左右孩子都搞掂了，父节点可以出栈了，稳。</p><h5 id="【代码实现】-4"><a href="#【代码实现】-4" class="headerlink" title="【代码实现】"></a>【代码实现】</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur2</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(h != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        stack.push(h);</span><br><span class="line">        Node c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            c = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(c.left != <span class="keyword">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right)&#123;</span><br><span class="line">                stack.push(c.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c.right != <span class="keyword">null</span> &amp;&amp; h != c.right)&#123;</span><br><span class="line">                stack.push(c.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.print(stack.pop() + <span class="string">"  "</span>);</span><br><span class="line">                h = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">System.out.println();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文将简单介绍一下二叉树的先序、中序、后序遍历的递归实现和非递归实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>两个链表相交的一系列问题</title>
    <link href="http://yoursite.com/2018/08/17/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/17/两个链表相交的一系列问题/</id>
    <published>2018-08-17T14:32:29.000Z</published>
    <updated>2018-08-17T16:48:22.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p>在本题中，单链表可能有环，也可能无环。给定两个单链表的头节点 head1 和 head2 ，这两个链表可能相交，也可能不相交。请实现一个函数， 如果两个链表相交，请返回相交的第一个节点；如果不相交，返回null 即可。<br>要求：如果链表1的长度为N，链表2的长度为M，时间复杂度请达到 O(N+M)，额外空间复杂度请达到O(1)。<br><a id="more"></a></p><h3 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个问题其实包含了很多子问题，首先是链表有无环的问题，再就是链表是否相交，还有注意题目，是单链表，划重点了，因此不要想着链表会相交会出现相交成 X 型的，单链表相交必定是成 Y 型的,而且如果成环相交，必定是同一个环。再分析一下，这道题就必定只会有这几种情况，各自成环不相交，成环相交两种，无环相交。针对以上几种情况，可以用 getLoopNode() 函数来判断链表是否成环，再用 noLoop() 来处理无环相交的情况，或者使用 bothLoop() 函数来处理成环相交。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体讲一下 getLoopNode() 函数，首先判断一下链表是否大于三个节点，否则你成个鸡儿环？然后定义一个慢指针 slow 一次走一步，还有一个快指针 fast 一次走两步,如果说指针走不回原处，证明无环， 当两个指针相遇是退出循环，将快指针指向头节点，然后继续走，他们相遇的点就是成环点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;noLoop() 无环相交的情况 ，首先判断一下，如果一方是空的，就不可能相交。然后将指针分别挪到最后，因为是单链表且不成环，所以如果他们最后一个节点不相等就不可能相交。再定位一下谁是长链表，将 cur1 指向 长链表，cur2 指向短链表 。然后长的先走多出来的那几步，然后再一起走，相遇的的点就是相交点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bothLoop() 有环相交有三种情况，第一种是相交城一个 Y 下面成环，这种情况可以将下面的换忽略掉下面的环，变成无环相交的情况，第二、三种是下面一个环，上面两个链表不相交的情况，或者两个链表成环不相交，因此我们将指针 cur1 挪到链表一的成环点，一直挪，如果走了一圈都没有遇到 loop2 证明是第三种情况，拉黑返回空，否则返回 loop1 。</p><h3 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1,Node head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="keyword">null</span> || head2 ==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node loop1 = getLoopNode(head1);</span><br><span class="line">    Node loop2 = getLoopNode(head2);  </span><br><span class="line">    <span class="keyword">if</span>(loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>)&#123;<span class="comment">// 无环相交问题</span></span><br><span class="line">        <span class="keyword">return</span> noLoop(head1 ,head2);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> bothLoop(head1, loop1, loop2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span>( slow != fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1,Node head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur1 = head1;</span><br><span class="line">    Node cur2 = head2;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur1.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cur2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur1 != cur2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur1 = n &gt; <span class="number">0</span> ? head1 :head2;</span><br><span class="line">    cur2 = cur1 == head1 ? head2 :head1;</span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cur1 != cur2)&#123;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1,Node head2, Node loop2)</span></span>&#123;</span><br><span class="line">    Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">    Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(loop1 == loop2)&#123;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != loop1 )&#123;</span><br><span class="line">            n++l</span><br><span class="line">            cur1 = cur1.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur2 != loop2)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span>(cur1 != cur2)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != loop1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == loop2)&#123;</span><br><span class="line">                <span class="keyword">return</span> loop1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目】&quot;&gt;&lt;a href=&quot;#【题目】&quot; class=&quot;headerlink&quot; title=&quot;【题目】&quot;&gt;&lt;/a&gt;【题目】&lt;/h3&gt;&lt;p&gt;在本题中，单链表可能有环，也可能无环。给定两个单链表的头节点 head1 和 head2 ，这两个链表可能相交，也可能不相交。请实现一个函数， 如果两个链表相交，请返回相交的第一个节点；如果不相交，返回null 即可。&lt;br&gt;要求：如果链表1的长度为N，链表2的长度为M，时间复杂度请达到 O(N+M)，额外空间复杂度请达到O(1)。&lt;br&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>复制有随机指针节点的链表</title>
    <link href="http://yoursite.com/2018/08/17/%E5%A4%8D%E5%88%B6%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/08/17/复制有随机指针节点的链表/</id>
    <published>2018-08-17T12:02:26.000Z</published>
    <updated>2018-08-17T14:01:25.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p>一种特殊的链表节点类描述如下：<br>public class Node { public int value; public Node next; public<br>Node rand;<br>public Node(int data) { this.value = data; }<br>}<br><a id="more"></a><br>Node类中的value是节点值，next指针和正常单链表中next指针的意义样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可 能指向链表中的任意一个节点，也可能指向null。 给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个 函数完成这个链表中所有结构的复制，并返回复制的新链表的头节点。 进阶：不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N) 内完成原问题要实现的函数。</p><h3 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现思路很简单，生成一个哈希表，将原链表的节点作为 key ,新链表的节点作为 value 放到一个 map 中，然后将链表节点一个个连起来，顺便把链表的 rand 指针指向也填补上，稳了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的实现方法不是重点，虽然很简单，还挺快，但是毕竟是在面试当中，这里用了额外的空间，所以下面讲一下不需要额外空间的实现思路。实现的方法其实大同小异，因为首先就要求时间复杂度为 O(N) ，又不能有额外空间，那么只能把新链表的节点放在就链表的后面了，复制完成后再分开来。</p><h3 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand1</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node,Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.put(cur,<span class="keyword">new</span> Node(cur.value));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.get(cur).next = map.get(cur.next);</span><br><span class="line">        map.get(cur).rand = map.get(cur.rand);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand2</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">new</span> Node(cur.value);</span><br><span class="line">        cur.next.next = next;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    Node curCopy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        curCopy = cur.rand != <span class="keyword">null</span> ? cur.rand.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node res = head.next;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        cur.next = next;</span><br><span class="line">        curCopy.next = next != <span class="keyword">null</span> ? next.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目】&quot;&gt;&lt;a href=&quot;#【题目】&quot; class=&quot;headerlink&quot; title=&quot;【题目】&quot;&gt;&lt;/a&gt;【题目】&lt;/h3&gt;&lt;p&gt;一种特殊的链表节点类描述如下：&lt;br&gt;public class Node { public int value; public Node next; public&lt;br&gt;Node rand;&lt;br&gt;public Node(int data) { this.value = data; }&lt;br&gt;}&lt;br&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>将单向链表按值分成左中右三个等份</title>
    <link href="http://yoursite.com/2018/08/16/%E5%B0%86%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%8C%89%E5%80%BC%E5%88%86%E6%88%90%E5%B7%A6%E4%B8%AD%E5%8F%B3%E4%B8%89%E4%B8%AA%E7%AD%89%E4%BB%BD/"/>
    <id>http://yoursite.com/2018/08/16/将单向链表按值分成左中右三个等份/</id>
    <published>2018-08-16T14:43:14.000Z</published>
    <updated>2018-08-16T16:14:18.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p>给定一个单向链表的头节点 head ，节点的值类型是整型，再给定一个整数 pivot 。实现一个调整链的函数，将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点，右部分都是值大于 pivot 的节点。除这个要求外，对调整后的节点顺序没有更多的要求。<br><a id="more"></a><br>进阶： 在原问题的要求之上再增加如下两个要求。在左、中、右三个部分的内部也做顺序要求，要求每部分里的节点从左 到右的顺序与原链表中节点的先后次序一致。如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。</p><h3 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先看最基本的要求，不要求稳定性，那这题不就是荷兰国旗问题的嘛，将链表的节点全部放到数组当中，然后 Partition() 一下不就稳了，最后把弄好的数组放回到链表中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本的要求很简单，再来看看进阶要求，其实就是要求不借助额外空间。实现起来也很简单，就是麻烦一点，说白了不就是先将链表遍历链表，然后将分别三种不同情况（大于，小于，等于）的节点分别连起来嘛，但是还是会有一些特殊情况出现，比如三种情况可能不会全部出现，这个时候直接连起来就会出现问题，不过这都细节问题，连的时候判断处理一下不就稳了嘛，说干就干。</p><h3 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition1</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] nodeArr = <span class="keyword">new</span> Node[i];</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nodeArr.length; i++)&#123;</span><br><span class="line">        nodeArr[i] = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    arrPartition(nodeArr, pivot);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; nodeArr.length; i++)&#123;</span><br><span class="line">        nodeArr[i-<span class="number">1</span>].next = nodeArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodeArr[i - <span class="number">1</span>].next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrPartition</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> small = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> big = nodeArr.length;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index != big) &#123;</span><br><span class="line"><span class="keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;</span><br><span class="line">swap(nodeArr, ++small, index++);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeArr[index].value == pivot) &#123;</span><br><span class="line">index++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">swap(nodeArr, --big, index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">Node tmp = nodeArr[a];</span><br><span class="line">nodeArr[a] = nodeArr[b];</span><br><span class="line">nodeArr[b] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head,<span class="keyword">int</span> pivot)</span></span>&#123;</span><br><span class="line">    Node sH = <span class="keyword">null</span>;</span><br><span class="line">    Node sT = <span class="keyword">null</span>;</span><br><span class="line">    Node eH = <span class="keyword">null</span>;</span><br><span class="line">    Node eT = <span class="keyword">null</span>;</span><br><span class="line">    Node bH = <span class="keyword">null</span>;</span><br><span class="line">    Node bT = <span class="keyword">null</span>;    </span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.value &lt; pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                sH = sT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sT.next = head;</span><br><span class="line">                sT.next = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value == pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(eH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                eH = eT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                eT.next = head;</span><br><span class="line">                eT.next = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value &gt; pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                bH = bT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bT.next = head;</span><br><span class="line">                bT.next = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sT != <span class="keyword">null</span>)&#123;</span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT : eT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(eT != <span class="keyword">null</span>)&#123; <span class="comment">//eT如果是空在上一步被换成了sT</span></span><br><span class="line">        eT.next = bH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : eH != <span class="keyword">null</span> ? eH : bH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目】&quot;&gt;&lt;a href=&quot;#【题目】&quot; class=&quot;headerlink&quot; title=&quot;【题目】&quot;&gt;&lt;/a&gt;【题目】&lt;/h3&gt;&lt;p&gt;给定一个单向链表的头节点 head ，节点的值类型是整型，再给定一个整数 pivot 。实现一个调整链的函数，将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点，右部分都是值大于 pivot 的节点。除这个要求外，对调整后的节点顺序没有更多的要求。&lt;br&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>判断一个链表是否为回文结构</title>
    <link href="http://yoursite.com/2018/08/15/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/08/15/判断一个链表是否为回文结构/</id>
    <published>2018-08-15T12:11:50.000Z</published>
    <updated>2018-08-15T13:47:17.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p>给定一个链表的头节点head，请判断该链表是否为回文结构。 例如： 1-&gt;2-&gt;1，返回true。 1-&gt;2-&gt;2-&gt;1，返回15-&gt;6-&gt;15，返回true。 1-&gt;2-&gt;3，返回false。true。<br>进阶： 如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。<br><a id="more"></a></p><h3 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题要解决还是非常简单，首先讲两种简单的解决思路。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种实现思路非常简单，回文结构顾名思义正着看和反着看顺序都是一样的，那样判断就很简单啦，将链表整个反转过来一比较不就知道了，反转不就是逆序吗，刚好栈的特点就是先进后出，不就是逆序吗，一拍即合，于是将链表整个放进栈里面，再一个个出栈比较，稳了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种思路也差不多,因为回文的结构特点，所以回文必定是对称的，所以我们完全可以只将后半段入栈，然后比较一下不就稳了，具体实现可以使用两个指针，慢指针一次走一步，慢指针一次走两步，快指针走完，慢指针刚好走到中间，然后将慢指针直到末尾的结点入栈，然后比较，打完收工。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三种思路无聊一点，但是面试要考，这种思路的主要特点是不需要额外的空间，直接改变列表的顺序，再比较，然后恢复。具体实现按部就班，两个指针，一快一慢，走到最后，快指针 n2 指向末尾，慢指针 n1 指向中间。然后将快指针 n2 指向慢指针 n1 的后一位，然后从中间将链表分成两半，然后将 n2 的下一位给 n3 ，记录下下一位的位置，然后将 n2 指向的结点指向 n1,然后将 n1 ， n2 的位置向右移，依次类推直到 n2 移到最后，这个过程将链表的后半段的指向颠倒了过来，相当于 1-&gt;2-&gt;2-&gt;1,变成 1-&gt;2&lt;-2&lt;-1。然后不经意地将链表元素头尾比较了一遍，稳了。最后将链表复原。</p><h3 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeFirst</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(cur.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.value != stack.pop().value)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeSecond</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node right = head.next;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        right = right.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span>(right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(right);</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.value != stack.pop().value&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeThird</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node n1 = head;</span><br><span class="line">    Node n2 = head;</span><br><span class="line">    <span class="keyword">while</span>(n2.next != <span class="keyword">null</span> &amp;&amp; n2.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n2 = n1.next;</span><br><span class="line">    n1.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Node n3 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//颠倒链表后半段顺序</span></span><br><span class="line">    <span class="keyword">while</span>(n2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n3 = n2.next;</span><br><span class="line">        n2.next = n1;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">    &#125;</span><br><span class="line">    n3 = n1;<span class="comment">//记录下链表的末尾位置</span></span><br><span class="line">    n2 = head;<span class="comment">//链表头</span></span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="keyword">null</span> &amp;&amp; n2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n1.value ！= n2.value&#123;</span><br><span class="line">            res = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n1 = n3.next;</span><br><span class="line">    n3.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(n1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n2 = n1.next;</span><br><span class="line">        n1.next = n3;</span><br><span class="line">        n3 = n1;</span><br><span class="line">        n1 = n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目】&quot;&gt;&lt;a href=&quot;#【题目】&quot; class=&quot;headerlink&quot; title=&quot;【题目】&quot;&gt;&lt;/a&gt;【题目】&lt;/h3&gt;&lt;p&gt;给定一个链表的头节点head，请判断该链表是否为回文结构。 例如： 1-&amp;gt;2-&amp;gt;1，返回true。 1-&amp;gt;2-&amp;gt;2-&amp;gt;1，返回15-&amp;gt;6-&amp;gt;15，返回true。 1-&amp;gt;2-&amp;gt;3，返回false。true。&lt;br&gt;进阶： 如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。&lt;br&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>生成窗口最大值数组</title>
    <link href="http://yoursite.com/2018/08/09/%E7%94%9F%E6%88%90%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/08/09/生成窗口最大值数组/</id>
    <published>2018-08-09T11:47:28.000Z</published>
    <updated>2018-08-13T14:42:50.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，数组为[4,3,5,4,3,3,6,7],窗口为3时，依次出现的窗口为[4,3,5], [3,5,4], [5,4,3], [4,3,3], [3,3,6], [3,6,7]。　如果数组长度是n，窗口大小是w，则一共产生n-w+1个窗口。<br>    请实现一个函数。<br>　　1、输入：整型数组arr，窗口大小w<br>　　2、输出：一个长度大小为n-w+1的数组res，res[i]表示每一种窗口下的最大值。例如上面的例子，应该返回[5,5,5,4,6,7]。<br><a id="more"></a></p><h3 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题还算简单，做题前先理清思路，我们选用双端队列  qMax 来存储下标值，如果队列是空的，不用说什么下标先入队，如果不为空并且 arr[i] 的值大于 队尾的值，队尾值出队，继续比较 如此类推，直到队列为空 ，或者队尾的值比 arr[i] 更大才跳出循环。经过前面的这番操作，先不管什么，把下标值按规则入队先，但是还要解决一下下标超过窗口值的问题，还有就是前面几个下标如果还没有达到窗口值就不能确定窗口的最大值。解决的方法还是很简单的，前者可以将i(就是当前最后一个值的下标)-w  == 队头值就证明已经越界了，赶紧队头出来。后者的话就判断一下，当对 i + 1 &gt;= w 就证明过了窗口值了，可以出队头了。稳。</p><h3 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getMaxWindow(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> w)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || w &lt; <span class="number">1</span> || arr.length &lt; w)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length - w + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[i])&#123;</span><br><span class="line">            qmax.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        qmax.addLast(i);</span><br><span class="line">        <span class="keyword">if</span>(qmax.peekFirst() == i-w)&#123;</span><br><span class="line">            qmax.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= w - <span class="number">1</span>)&#123;</span><br><span class="line">            res[index++] = arr[qmax.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目】&quot;&gt;&lt;a href=&quot;#【题目】&quot; class=&quot;headerlink&quot; title=&quot;【题目】&quot;&gt;&lt;/a&gt;【题目】&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;例如，数组为[4,3,5,4,3,3,6,7],窗口为3时，依次出现的窗口为[4,3,5], [3,5,4], [5,4,3], [4,3,3], [3,3,6], [3,6,7]。　如果数组长度是n，窗口大小是w，则一共产生n-w+1个窗口。&lt;br&gt;    请实现一个函数。&lt;br&gt;　　1、输入：整型数组arr，窗口大小w&lt;br&gt;　　2、输出：一个长度大小为n-w+1的数组res，res[i]表示每一种窗口下的最大值。例如上面的例子，应该返回[5,5,5,4,6,7]。&lt;br&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>用数组结构实现大小固定的队列和栈</title>
    <link href="http://yoursite.com/2018/08/07/%E7%94%A8%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%A4%A7%E5%B0%8F%E5%9B%BA%E5%AE%9A%E7%9A%84%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"/>
    <id>http://yoursite.com/2018/08/07/用数组结构实现大小固定的队列和栈/</id>
    <published>2018-08-07T13:50:13.000Z</published>
    <updated>2018-08-07T15:07:19.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用数组结构实现大小固定的队列和栈</p><a id="more"></a><h3 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题很基础，讲一下实现思路。首先用数组实现一个大小固定的栈，栈结构的特点是先进后出，所以我们可以定义一个变量 index 来指向数组中的栈顶的上一个位置，如果有 push 操作就将元素放到 arr[index++] ，peak 操作就输出 arr[index - 1], pop 操作就 arr[- -index],用index来控制数组不要越界，index 等于 0 时就到栈底了，index 等于数组长度时就到栈顶了，数组越界的话就报错。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现一个固定的队列的话会更复杂一点，首先定义两个变量 start 和 end 分别指向 队列的开头和末尾，再定义一个变量 size 用来记录队列的元素，就能将 start 和 end 的关系解耦，只要 size 的值在允许的范围内， start 和 end 都可以随意操作，到末尾了就从头开始。</p><h3 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer[] arr;</span><br><span class="line">    <span class="keyword">private</span> Integer index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> initSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(initSize &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the init is less than 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr = <span class="keyword">new</span> Integer[initSize];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[index -<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == arr.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The stack is full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsExceptiion(<span class="string">"The stack is empty "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[--index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer[] arr;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> Integer start;</span><br><span class="line">    <span class="keyword">private</span> Integer end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(initSize &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the init is less than 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr = <span class="keyword">new</span> Integer[initSize];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == arr.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOfBoundsException(<span class="string">"The queue is full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        arr[end] = obj;</span><br><span class="line">        end = end == arr.length - <span class="number">1</span> ? <span class="number">0</span> : end + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;   </span><br><span class="line">        <span class="keyword">int</span> tmp = start;</span><br><span class="line">        start = arr.length -<span class="number">1</span> ? <span class="number">0</span> : end + <span class="number">1</span>;    </span><br><span class="line">        <span class="keyword">return</span> arr[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目】&quot;&gt;&lt;a href=&quot;#【题目】&quot; class=&quot;headerlink&quot; title=&quot;【题目】&quot;&gt;&lt;/a&gt;【题目】&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用数组结构实现大小固定的队列和栈&lt;/p&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://yoursite.com/2018/08/06/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/08/06/堆排序/</id>
    <published>2018-08-06T11:17:06.000Z</published>
    <updated>2018-08-09T15:52:48.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【基本思想】"><a href="#【基本思想】" class="headerlink" title="【基本思想】"></a>【基本思想】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆排序的基本思想是将待排序列构造成一个大根堆(小根堆)，将堆顶元素输出，得到序列中的最大值。再将堆顶元素和堆尾元素进行交换，并重建堆，以此类推直到得到一个有序序列。<br><a id="more"></a></p><h3 id="【算法复杂度】"><a href="#【算法复杂度】" class="headerlink" title="【算法复杂度】"></a>【算法复杂度】</h3><div class="table-container"><table><thead><tr><th>排序方法</th><th style="text-align:center">时间复杂度（平均）</th><th style="text-align:center">时间复杂度 （最坏）</th><th style="text-align:center">时间复杂度（最好）</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td>堆排序</td><td style="text-align:center">$O(nlogn)$</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr></tbody></table></div><h3 id="【动图演示】"><a href="#【动图演示】" class="headerlink" title="【动图演示】"></a>【动图演示】</h3><img src="/2018/08/06/堆排序/93824bbcbb3c16dbfd58a0e64d2c7c3c_849589-20171015231308699-356134237.gif" title="堆排序"><h3 id="【算法实现】"><a href="#【算法实现】" class="headerlink" title="【算法实现】"></a>【算法实现】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆排序的实现非常简单，总的来说就是不断将大根堆的堆顶元素与堆尾元素交换，再重建大根堆的过程。首先判断先判断一下数组大小，少于两个元素的数组排个鸡儿序。然后将待排序列构建成大根堆，用变量 heapSize 来控制堆的大小，然后不断地 heapify ，直到 heapSize 等于零。在 heapify 的过程中就是先比较子节点的大小，然后比较父节点和子节点的大小，如果最后发现父节点是比子节点大的话跳出 heapify 循环，否则将子节点与父节点交换，并且找到子节点的左孩子，再重复上诉过程，直到左孩子的位置 left 大于 heapSize ，heapify 循环结束.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arr.length; i++)&#123;</span><br><span class="line">        heapInsert(arr,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">    <span class="keyword">while</span>(heapSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        heapify(arr, <span class="number">0</span>, heapify);</span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>])&#123;</span><br><span class="line">        swap(arr, index, (index -<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        index = (index -<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; heapSize)&#123;</span><br><span class="line">        <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left</span><br><span class="line">        largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span>(largest == index)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, largest, index);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【基本思想】&quot;&gt;&lt;a href=&quot;#【基本思想】&quot; class=&quot;headerlink&quot; title=&quot;【基本思想】&quot;&gt;&lt;/a&gt;【基本思想】&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;堆排序的基本思想是将待排序列构造成一个大根堆(小根堆)，将堆顶元素输出，得到序列中的最大值。再将堆顶元素和堆尾元素进行交换，并重建堆，以此类推直到得到一个有序序列。&lt;br&gt;
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://yoursite.com/2018/08/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/08/05/快速排序/</id>
    <published>2018-08-05T15:30:51.000Z</published>
    <updated>2018-08-05T16:26:13.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【基本思想】"><a href="#【基本思想】" class="headerlink" title="【基本思想】"></a>【基本思想】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速排序的基本思想就是通过一趟排序以基准元素为界限将待排序列分割成两个独立的部分，然后再对两个独立的部分进行快排，依次类推直到序列整体有序。<br><a id="more"></a></p><h3 id="【算法复杂度】"><a href="#【算法复杂度】" class="headerlink" title="【算法复杂度】"></a>【算法复杂度】</h3><div class="table-container"><table><thead><tr><th>排序方法</th><th style="text-align:center">时间复杂度（平均）</th><th style="text-align:center">时间复杂度 （最坏）</th><th style="text-align:center">时间复杂度（最好）</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td>快速排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(logn)</td><td style="text-align:center">不稳定</td></tr></tbody></table></div><h3 id="【动图演示】"><a href="#【动图演示】" class="headerlink" title="【动图演示】"></a>【动图演示】</h3><img src="/2018/08/05/快速排序/eaca66d26efe27519e8c462d3a7d4593_849589-20171015230936371-1413523412.gif" title="快速排序"><h3 id="【算法实现】"><a href="#【算法实现】" class="headerlink" title="【算法实现】"></a>【算法实现】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速排序实现起来很简单，先用 L&lt;R 来控制快排是否发生，如果条件满足则进行快排。而具体的每一次排序和荷兰国旗问题很相像，不过这里的基准元素选择了最后一个数来充当，同样的比 arr[R] 小的放左边，大的放右边，相等的放中间，最后再将 arr[R] 与 大于它的第一位数交换，稳了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt; R)&#123;</span><br><span class="line">        <span class="keyword">int</span> [] p = partition(arr,L,R);</span><br><span class="line">        quickSort(arr, L, p[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, p[<span class="number">1</span>] + <span class="number">1</span>,R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = R ;</span><br><span class="line">    <span class="keyword">while</span>(L &lt; more)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[L] &lt; arr[R])&#123;</span><br><span class="line">            swap(arr, ++less, L++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[L] &gt; arr[R])&#123;</span><br><span class="line">            swap(arr, --more, L);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            L++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr,more,R);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;less + <span class="number">1</span>, more&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【算法优化】"><a href="#【算法优化】" class="headerlink" title="【算法优化】"></a>【算法优化】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实上面的实现已经是经典快排的优化版了，在经典快排中每次就只排好一个数，就是那个基准元素，如果基准元素不止一个，在下一次的排序当中又要对这个元素进行排序。而上面的实现是把等于这个基准元素的元素一整片都排好了，所以相对经典快排，上面的实现会更快一点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的实现中其实有一个很严重的问题，当待排序列是有序的时候，因为每次都选最后一个值来当基准元素，所以 partition 这个过程会被重复 n 次，这样快排就会退化成 O(n^2) 的算法了。为了解决这个问题，所以选基准元素的时候就采用随机选取的方式来选取，这也就是<strong>随机快排</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &lt; R)&#123;</span><br><span class="line">        swap(arr, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span> )), R);</span><br><span class="line">        <span class="keyword">int</span> [] p = partition(arr,L,R);</span><br><span class="line">        quickSort(arr, L, p[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, p[<span class="number">1</span>] + <span class="number">1</span>,R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = R ;</span><br><span class="line">    <span class="keyword">while</span>(L &lt; more)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[L] &lt; arr[R])&#123;</span><br><span class="line">            swap(arr, ++less, L++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[L] &gt; arr[R])&#123;</span><br><span class="line">            swap(arr, --more, L);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            L++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr,more,R);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;less + <span class="number">1</span>, more&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【基本思想】&quot;&gt;&lt;a href=&quot;#【基本思想】&quot; class=&quot;headerlink&quot; title=&quot;【基本思想】&quot;&gt;&lt;/a&gt;【基本思想】&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;快速排序的基本思想就是通过一趟排序以基准元素为界限将待排序列分割成两个独立的部分，然后再对两个独立的部分进行快排，依次类推直到序列整体有序。&lt;br&gt;
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>荷兰国旗问题</title>
    <link href="http://yoursite.com/2018/08/05/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/05/荷兰国旗问题/</id>
    <published>2018-08-05T14:35:31.000Z</published>
    <updated>2018-08-05T15:53:12.811Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放在数组的中间，大于num的数放在数组的右边。<br>要求额外空间复杂度O(1)，时间复杂度O(N)。</p><a id="more"></a><h3 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题可以简单地使用双指针法来解决，定义两个指针变量 less 和 more<br> ，分别用来记录小于 num 和大于 num 的范围，用变量 cur 来记录数组遍历的位置，遍历过程中将小于 num 的数交换到 less 的后一位再 less++ , 大于 num 的数交换到 more 的前一位再 more - - ，遇到等于 num 的数 cur 就直接跳到下一位。写过快排的兄 dei 应该会觉得很熟悉，这就是一次排序的过程。</p><h3 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R,<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = R + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = L ;</span><br><span class="line">    <span class="keyword">while</span>(cur &lt; more)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[cur] &lt; num)&#123;</span><br><span class="line">            swap(arr, ++less, cur++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[cur] &gt; num)&#123;</span><br><span class="line">            swap(arr, --more, cur);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;less+<span class="number">1</span>,more-<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目】&quot;&gt;&lt;a href=&quot;#【题目】&quot; class=&quot;headerlink&quot; title=&quot;【题目】&quot;&gt;&lt;/a&gt;【题目】&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放在数组的中间，大于num的数放在数组的右边。&lt;br&gt;要求额外空间复杂度O(1)，时间复杂度O(N)。&lt;/p&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>小和问题</title>
    <link href="http://yoursite.com/2018/08/05/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/05/小和问题/</id>
    <published>2018-08-04T18:10:20.000Z</published>
    <updated>2018-08-15T12:12:39.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。<br><a id="more"></a></p><p>例子：<br>[1,3,4,2,5]<br>1左边比1小的数，没有；<br>3左边比3小的数，1；<br>4左边比4小的数，1、3；<br>2左边比2小的数，1；<br>5左边比5小的数，1、3、4、2；<br>所以小和为1+1+3+1+1+3+4+2=16</p><h3 id="【解答】"><a href="#【解答】" class="headerlink" title="【解答】"></a>【解答】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果学过归并排序还是能比较简单地完成这道题。归并排序的归并过程中会对序列中的元素进行比较，如果左边的数比右边的数小，则证明右边往后有多少个数比左边的数大可以算出小和为 arr[p1] * (R-p2+1)</p><h3 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L +((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> sortProcess(arr,L,mid) +</span><br><span class="line">    sortProcess(arr,mid+<span class="number">1</span>,R) +</span><br><span class="line">        merge(arr,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">        res += arr[p1] &lt; arr[p2] ? arr[p1]*(R-p2+<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">        arr[L+i]  = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【题目】&quot;&gt;&lt;a href=&quot;#【题目】&quot; class=&quot;headerlink&quot; title=&quot;【题目】&quot;&gt;&lt;/a&gt;【题目】&lt;/h3&gt;&lt;p&gt;在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。&lt;br&gt;
    
    </summary>
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://yoursite.com/2018/08/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/08/05/归并排序/</id>
    <published>2018-08-04T16:39:33.000Z</published>
    <updated>2018-08-05T07:13:51.157Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【基本思想】"><a href="#【基本思想】" class="headerlink" title="【基本思想】"></a>【基本思想】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;归并排序的基本思想是采用分治法，将已有的有序子序列合并，得到一个完整的有序序列<br><a id="more"></a></p><h3 id="【算法复杂度】"><a href="#【算法复杂度】" class="headerlink" title="【算法复杂度】"></a>【算法复杂度】</h3><div class="table-container"><table><thead><tr><th>排序方法</th><th style="text-align:center">时间复杂度（平均）</th><th style="text-align:center">时间复杂度 （最坏）</th><th style="text-align:center">时间复杂度（最好）</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td>归并排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n)</td><td style="text-align:center">稳定</td></tr></tbody></table></div><h3 id="【动图演示】"><a href="#【动图演示】" class="headerlink" title="【动图演示】"></a>【动图演示】</h3><img src="/2018/08/05/归并排序/2f9f62d486be19b87a3f37f13eb75786_849589-20171015230557043-37375010.gif" title="归并排序"><h3 id="【算法实现】"><a href="#【算法实现】" class="headerlink" title="【算法实现】"></a>【算法实现】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;归并排序的实现思路很简单，将长度为 n 的序列分成两个长度为 2/n 的子序列，然后对着两个子序列进行归并排序，子序列又被分成子序列再进行归并排序，最终对有序子序列进行归并，得到最终的有序序列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSore</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span>|| arr.length &lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sortProcess(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L +((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    sortProcess(arr,L,mid);</span><br><span class="line">    sortProcess(arr,mid+<span class="number">1</span>,R);</span><br><span class="line">    merge(arr,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">        arr[L+i]  = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="【算法优化】"><a href="#【算法优化】" class="headerlink" title="【算法优化】"></a>【算法优化】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在序列有序的情况下不做归并操作</strong>，在上面的实现中直接对两个子序列进行 merge 操作，但是如果序列本身就近乎有序，那么这两个子序列出现有序的几率会大很大。如果可以避免掉对有序序列的 merge 操作，性能会有所提升，所以做 merge 操作前应该先判断一下两个子序列是否本身就有序，如果有序就不用做 merge 操作了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSore</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span>|| arr.length &lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sortProcess(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L +((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    sortProcess(arr,L,mid);</span><br><span class="line">    sortProcess(arr,mid+<span class="number">1</span>,R);</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] &gt; arr[mid+<span class="number">1</span>])&#123;</span><br><span class="line">        merge(arr,L,mid,R);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">        arr[L+i]  = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在子序列元素较少的时候使用插入排序来提高性能</strong>，同样的，在一个几乎有序的序列中，当归并排序的序列被分到很小的情况下，序列中的元素更少，这时候出现有序序列的几率会大很多，而插入排序对近乎有序的序列时间复杂度会变成 O(n) ，性能会有提高。另一方面，O(n^2) 在序列很小的时候会比 O(nlogn) 更小。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSore</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span>|| arr.length &lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sortProcess(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R - L &lt; <span class="number">15</span>)&#123;</span><br><span class="line">        insertionSort(arr, L, R);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L +((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    sortProcess(arr,L,mid);</span><br><span class="line">    sortProcess(arr,mid+<span class="number">1</span>,R);</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] &gt; arr[mid+<span class="number">1</span>])&#123;</span><br><span class="line">        merge(arr,L,mid,R);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">        arr[L+i]  = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="【自底向上的归并排序】"><a href="#【自底向上的归并排序】" class="headerlink" title="【自底向上的归并排序】"></a>【自底向上的归并排序】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有自顶向下的归并排序自然也有自底向上的归并排序,实现思路也很简单，通过外层循环控制子序列的大小，内层循环将子序列归并。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortBU</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz&lt;= n; sz += sz)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + sz &lt; n; i += sz + sz )&#123;</span><br><span class="line">            merge( arr, i, i + sz -<span class="number">1</span>, min(i + sz +sz -<span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R)&#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">        arr[L+i]  = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【基本思想】&quot;&gt;&lt;a href=&quot;#【基本思想】&quot; class=&quot;headerlink&quot; title=&quot;【基本思想】&quot;&gt;&lt;/a&gt;【基本思想】&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;归并排序的基本思想是采用分治法，将已有的有序子序列合并，得到一个完整的有序序列&lt;br&gt;
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2018/08/04/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/08/04/插入排序/</id>
    <published>2018-08-04T15:17:58.000Z</published>
    <updated>2018-08-04T15:57:31.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【基本思想】"><a href="#【基本思想】" class="headerlink" title="【基本思想】"></a>【基本思想】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入排序的基本思想就是从有序序列后往前扫描，找到合适的位置，插入。可以形象地比喻成我们打牌的时候整理牌的顺序的方法。<br><a id="more"></a></p><h3 id="【算法复杂度】"><a href="#【算法复杂度】" class="headerlink" title="【算法复杂度】"></a>【算法复杂度】</h3><div class="table-container"><table><thead><tr><th>排序方法</th><th style="text-align:center">时间复杂度（平均）</th><th style="text-align:center">时间复杂度 （最坏）</th><th style="text-align:center">时间复杂度（最好）</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td>插入排序</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td><td style="text-align:center">稳定</td></tr></tbody></table></div><h3 id="【动图演示】"><a href="#【动图演示】" class="headerlink" title="【动图演示】"></a>【动图演示】</h3><img src="/2018/08/04/插入排序/6d867acd56e40fb32975f9e91d041fa9_849589-20171015225645277-1151100000.gif" title="插入排序"><h3 id="【算法实现】"><a href="#【算法实现】" class="headerlink" title="【算法实现】"></a>【算法实现】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现思路很简单，先判断一下数组大小，少于两个元素的数组排个鸡儿序。外层循环用 i 控制循环，直到最后一个元素，内层循环当满足 arr[j] 不会越界并且 arr<a href="有序序列最后一位">j</a> 与 arr[j+1] 相比较更大时发生交换，然后 j— 直到找到合适的位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> class <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i -<span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j+<span class="number">1</span>]; j--)&#123;</span><br><span class="line">            swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="【算法优化】"><a href="#【算法优化】" class="headerlink" title="【算法优化】"></a>【算法优化】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的实现方法中每一次插入排序会不断地交换位置，直到插入数字找到合适的位置，打过牌的同学都知道，你不可能把牌直接放最后，然后一直交换，直到找到合适的位置，恕我直言这样做就像个傻逼，正常人应该会直接将牌插入到合适的位置。同理，我们也可以这样优化一下插入排序，我们定义一个变量 tmp 保存要插入的值，当要交换时我们先不交换，而是把元素往后挪一下，直到找到合适的位置，用变量 j 来记录应该插入的位置，然后直接插入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> class <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = i -<span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j+<span class="number">1</span>]; j--)&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【基本思想】&quot;&gt;&lt;a href=&quot;#【基本思想】&quot; class=&quot;headerlink&quot; title=&quot;【基本思想】&quot;&gt;&lt;/a&gt;【基本思想】&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;插入排序的基本思想就是从有序序列后往前扫描，找到合适的位置，插入。可以形象地比喻成我们打牌的时候整理牌的顺序的方法。&lt;br&gt;
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://yoursite.com/2018/08/04/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/08/04/选择排序/</id>
    <published>2018-08-04T14:19:25.000Z</published>
    <updated>2018-08-05T14:18:53.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【基本思想】"><a href="#【基本思想】" class="headerlink" title="【基本思想】"></a>【基本思想】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择排序的基本思想就是在未排序序列当中找到最小（最大）元素，然后将最小（最大）元素放到排序序列的末尾，依次类推，直到排序完毕。<br><a id="more"></a></p><h3 id="【算法复杂度】"><a href="#【算法复杂度】" class="headerlink" title="【算法复杂度】"></a>【算法复杂度】</h3><div class="table-container"><table><thead><tr><th>排序方法</th><th style="text-align:center">时间复杂度（平均）</th><th style="text-align:center">时间复杂度 （最坏）</th><th style="text-align:center">时间复杂度（最好）</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td>选择排序</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(n^2)</td><td style="text-align:center">O(1)</td><td style="text-align:center">不稳定</td></tr></tbody></table></div><h3 id="【动图演示】"><a href="#【动图演示】" class="headerlink" title="【动图演示】"></a>【动图演示】</h3><img src="/2018/08/04/选择排序/c7322fccb46e3cc0ea3c107781d1e880_849589-20171015224719590-1433219824.gif" title="选择排序"><h3 id="【算法实现】"><a href="#【算法实现】" class="headerlink" title="【算法实现】"></a>【算法实现】</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现思路很简单，先判断一下数组大小，少于两个元素的数组排个鸡儿序。外循环定义一个变量 i 控制循环过程，当 i = arr.length-1 的时候循环结束。然后内循环找出最小值，交换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,minIndex,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【基本思想】&quot;&gt;&lt;a href=&quot;#【基本思想】&quot; class=&quot;headerlink&quot; title=&quot;【基本思想】&quot;&gt;&lt;/a&gt;【基本思想】&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;选择排序的基本思想就是在未排序序列当中找到最小（最大）元素，然后将最小（最大）元素放到排序序列的末尾，依次类推，直到排序完毕。&lt;br&gt;
    
    </summary>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
